# 面接官に説明するためのコード確認メモ

面接で「ここを見て説明できる」ようにするためのファイル・行・ポイント一覧です。

---

## 1. 全体の流れ（データの流れ）

**`app/page.tsx`**

- **30〜37行**: 状態の定義（都市・指標・期間・単位・API生データ・loading・error）
- **48〜56行**: 初回マウントで `loadPrefs()` から localStorage を復元
- **59〜70行**: 選択が変わるたびに `savePrefs()` で localStorage に保存（100ms 遅延で連打を抑制）
- **74〜101行**: `load()` — API 取得。**loadIdRef** で二重リクエスト時の古い結果を捨て、**12秒タイムアウト**でローディング解除
- **104〜105行**: `load` が変わるたびに `useEffect` で再取得
- **109〜119行**: raw → transform → filter（今日以降）→ **applyUnitConversion** で表示用データに変換
- **説明のポイント**: 「状態は page に集約し、API → transform → 単位変換 → チャート、という一方向のデータフローにしています」

---

## 2. API 取得・キャッシュ・タイムアウト

**`lib/api.ts`**

- **7〜9行**: メモリキャッシュ（key: 緯度・経度・期間、TTL 5分）
- **11〜12行**: `cacheKey` — 同じ都市・期間ならキャッシュヒット
- **26〜33行**: キャッシュがあればそのまま返す（API を叩かない）
- **42〜48行**: リクエストパラメータ（hourly/daily は全指標まとめて取得、forecast_days・timezone）
- **52〜63行**: **AbortController** で 10 秒タイムアウト、`AbortError` ならユーザー向けメッセージに変換
- **66〜71行**: 429 は「リクエスト多すぎ」、それ以外は status 付きでエラー
- **74行**: 成功時はキャッシュに保存
- **説明のポイント**: 「レート制限を避けるため 5 分キャッシュ、UX のため 10 秒でタイムアウトしてエラー表示にしています」

---

## 3. 体感温度の「daily がない」ときの代替

**`lib/transform.ts`**

- **65〜84行**: 体感温度は API に daily がないため、**hourly の「日ごと先頭時刻」の値**を 1 日 1 点として使用。`time` を "YYYY-MM-DD" に統一して、気温の 7 日間データとマージできるようにしている。
- **説明のポイント**: 「体感温度は daily がないので、hourly を日付でグループ化し、各日の最初の時刻の値を代表値として使っています。time を日付だけにそろえて、気温と複数指標マージで同じ行に載るようにしています」

---

## 4. 複数指標のマージ（気温＋体感温度など）

**`lib/transform.ts`**

- **94〜115行**: `transformToChartDataMulti` — 各指標ごとに `transformToChartData` で点の配列を取得し、**time をキーに Map でマージ**。同じ time の点は `values` を結合（`...existing.values, ...p.values`）。最後に time でソート。
- **説明のポイント**: 「複数指標は、time をキーにして 1 つのデータ配列にマージしています。体感温度の 7 日間で time を YYYY-MM-DD にそろえたのは、このマージで気温の daily とキーを一致させるためです」

---

## 5. 単位変換（°C/°F、km/h/m/s）

**`lib/chartConvert.ts`**

- **7〜15行**: 表示ラベル（「気温」「体感温度」「最高気温」「最低気温」）から **MetricId** を引くマップを定義
- **25〜54行**: `applyUnitConversion` — 各点の `values` を走査し、metricId に応じて **convertTemp** / **convertWind** を適用。同時に `seriesUnits` に表示用単位（°C / °F など）を入れて、チャートの凡例で使う。
- **説明のポイント**: 「チャートに渡す前に単位変換を一括でかけています。系列名から指標を判定して気温は °C/°F、風速は km/h/m/s を切り替え、凡例用の単位ラベルもここで決めています」

**`lib/units.ts`**（換算式）

- 気温: F = C * 9/5 + 32
- 風速: m/s → km/h は × 3.6

---

## 6. 選択状態の永続化（localStorage）

**`lib/storage.ts`**

- **7行**: キー名 `tamable-weather-prefs`
- **27〜46行**: `ensureXxx` — ローカルストレージの値を検証（不正な値はデフォルトに戻す）
- **59〜73行**: `loadPrefs` — パースして各項目を ensure し、型安全な `SavedPrefs` を返す。SSR では `window` がないのでデフォルトを返す。
- **75〜81行**: `savePrefs` — JSON で保存。quota 超過やシークレットモードでは catch で握りつぶす。
- **説明のポイント**: 「localStorage の値をそのまま信じず、ensure で検証してから使っています。SSR 時は window がないのでデフォルトを返すようにしています」

---

## 7. 単位トグルの有効/無効（選択指標に連動）

**`components/UnitToggles.tsx`**

- **selectedMetricIds** を受け取り、**気温トグル**は「気温」「体感温度」のいずれかが含まれるときだけ有効、**風速トグル**は「風速」が含まれるときだけ有効。それ以外は `disabled` と説明文で「〇〇を選択中のみ変更できます」と表示。
- **説明のポイント**: 「選択している指標と関係ない単位は触れないようにし、無効時は理由を短く表示して分かりやすくしています」

---

## 8. チャート（Recharts）のデータ形式

**`components/WeatherChart.tsx`**

- **28〜44行**: `flattenChartData` — チャート用データは「全ポイントで出現するキー」を集めて、各ポイントを `{ label, ...values }` の行に変換。複数指標で系列がばらついても欠けずに描画。
- **46〜55行**: 系列名も「全ポイントの values のキー」から生成（先頭 1 点に依存しない）。
- **説明のポイント**: 「複数指標マージで系列が点ごとに違う場合があるので、系列名と flatten のキーは『全ポイントで出現するキー』から決めて、欠損なく描画するようにしています」

---

## 9. 定数・型の一元管理

**`lib/constants.ts`**

- 都市一覧（id, name, lat, lon）
- 指標一覧（id, label, unit, **hourly**, **daily**）— 体感温度は `daily: null`
- 期間・単位の選択肢

**`lib/types.ts`**

- Open-Meteo のレスポンス型、チャート用 `ChartDataPoint`（time, label, values）

---

## 面接で話すときの順番の例

1. **概要**: 「都市・指標・期間を選ぶと Open-Meteo から取得し、時系列でチャート表示する SPA です」
2. **データの流れ**: 「page で API を呼び、transform でチャート用に変換し、単位変換をかけてからチャートに渡しています」
3. **API**: 「キャッシュとタイムアウトで安定性を意識しています」（api.ts）
4. **体感温度**: 「daily がないので hourly の日ごと先頭を 1 日 1 点にしています」（transform.ts 65〜84）
5. **複数指標**: 「time をキーにマージして 1 本のグラフに重ねています」（transform.ts 94〜115）
6. **UX**: 「選択状態の localStorage 保存、単位トグルの有効/無効、エラー時は再試行ボタンで対応しています」

以上を押さえておけば、実装の意図を説明しやすいです。
